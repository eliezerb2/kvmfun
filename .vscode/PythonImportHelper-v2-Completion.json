[
    {
        "label": "libvirt",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "libvirt",
        "description": "libvirt",
        "detail": "libvirt",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "xml.etree.ElementTree",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xml.etree.ElementTree",
        "description": "xml.etree.ElementTree",
        "detail": "xml.etree.ElementTree",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "APIRouter",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "get_libvirt_domain",
        "importPath": "src.modules.disk_attach",
        "description": "src.modules.disk_attach",
        "isExtraImport": true,
        "detail": "src.modules.disk_attach",
        "documentation": {}
    },
    {
        "label": "get_next_available_virtio_dev",
        "importPath": "src.modules.disk_attach",
        "description": "src.modules.disk_attach",
        "isExtraImport": true,
        "detail": "src.modules.disk_attach",
        "documentation": {}
    },
    {
        "label": "attach_qcow2_disk",
        "importPath": "src.modules.disk_attach",
        "description": "src.modules.disk_attach",
        "isExtraImport": true,
        "detail": "src.modules.disk_attach",
        "documentation": {}
    },
    {
        "label": "detach_disk",
        "importPath": "src.modules.disk_detach",
        "description": "src.modules.disk_detach",
        "isExtraImport": true,
        "detail": "src.modules.disk_detach",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "disk_routes",
        "importPath": "src.api",
        "description": "src.api",
        "isExtraImport": true,
        "detail": "src.api",
        "documentation": {}
    },
    {
        "label": "get_libvirt_domain",
        "kind": 2,
        "importPath": "backup.attach_disk",
        "description": "backup.attach_disk",
        "peekOfCode": "def get_libvirt_domain(vm_name: str) -> tuple[libvirt.virConnect, libvirt.virDomain]:\n    \"\"\"\n    Establishes a libvirt connection and looks up a domain by name.\n    :param vm_name: The name of the virtual machine.\n    :type vm_name: str\n    :returns: A tuple containing the libvirt connection object and the domain object.\n    :rtype: tuple[libvirt.virConnect, libvirt.virDomain]\n    :raises RuntimeError: If connection fails or domain is not found.\n    \"\"\"\n    conn = None",
        "detail": "backup.attach_disk",
        "documentation": {}
    },
    {
        "label": "get_next_available_virtio_dev",
        "kind": 2,
        "importPath": "backup.attach_disk",
        "description": "backup.attach_disk",
        "peekOfCode": "def get_next_available_virtio_dev(dom: libvirt.virDomain) -> str:\n    \"\"\"\n    Finds the next available VirtIO block device target (e.g., 'vda', 'vdb', 'vdc', 'vdaa', etc.)\n    for a given VM by inspecting its current XML configuration.\n    It tracks ALL existing 'dev' names regardless of bus type and assigns an unused\n    virtio-style name that does not conflict with any existing 'dev' name.\n    :param dom: The libvirt Domain object for the VM.\n    :type dom: libvirt.virDomain\n    :returns: The next available VirtIO device name.\n    :rtype: str",
        "detail": "backup.attach_disk",
        "documentation": {}
    },
    {
        "label": "attach_qcow2_disk",
        "kind": 2,
        "importPath": "backup.attach_disk",
        "description": "backup.attach_disk",
        "peekOfCode": "def attach_qcow2_disk(dom: libvirt.virDomain, qcow2_path: str, target_dev: str) -> bool:\n    \"\"\"\n    Attaches a QCOW2 disk to a running KVM/QEMU VM using libvirt-python.\n    Confirms the disk was added after attachment.\n    If the disk with the specified path and target device is already attached,\n    it logs a warning and skips re-attachment.\n    :param dom: The libvirt Domain object for the VM.\n    :type dom: libvirt.virDomain\n    :param qcow2_path: The full path to the QCOW2 disk image file on the host.\n    :type qcow2_path: str",
        "detail": "backup.attach_disk",
        "documentation": {}
    },
    {
        "label": "QCOW2_DEFAULT_SIZE",
        "kind": 5,
        "importPath": "backup.attach_disk",
        "description": "backup.attach_disk",
        "peekOfCode": "QCOW2_DEFAULT_SIZE = \"1G\"\nLIBVIRT_DOMAIN_NAMESPACE = \"http://libvirt.org/schemas/domain/1.0\"\nNAMESPACES = {'lib': LIBVIRT_DOMAIN_NAMESPACE}\nVIRTIO_DISK_PREFIX = \"vd\"\n# --- End Constants ---\n# Helper functions\ndef _letters_to_int(s: str) -> int:\n    \"\"\"\n    Converts a letter sequence (e.g., 'a', 'aa') to a 0-indexed integer.\n    :param s: The letter sequence (e.g., 'a', 'b', 'aa').",
        "detail": "backup.attach_disk",
        "documentation": {}
    },
    {
        "label": "LIBVIRT_DOMAIN_NAMESPACE",
        "kind": 5,
        "importPath": "backup.attach_disk",
        "description": "backup.attach_disk",
        "peekOfCode": "LIBVIRT_DOMAIN_NAMESPACE = \"http://libvirt.org/schemas/domain/1.0\"\nNAMESPACES = {'lib': LIBVIRT_DOMAIN_NAMESPACE}\nVIRTIO_DISK_PREFIX = \"vd\"\n# --- End Constants ---\n# Helper functions\ndef _letters_to_int(s: str) -> int:\n    \"\"\"\n    Converts a letter sequence (e.g., 'a', 'aa') to a 0-indexed integer.\n    :param s: The letter sequence (e.g., 'a', 'b', 'aa').\n    :type s: str",
        "detail": "backup.attach_disk",
        "documentation": {}
    },
    {
        "label": "NAMESPACES",
        "kind": 5,
        "importPath": "backup.attach_disk",
        "description": "backup.attach_disk",
        "peekOfCode": "NAMESPACES = {'lib': LIBVIRT_DOMAIN_NAMESPACE}\nVIRTIO_DISK_PREFIX = \"vd\"\n# --- End Constants ---\n# Helper functions\ndef _letters_to_int(s: str) -> int:\n    \"\"\"\n    Converts a letter sequence (e.g., 'a', 'aa') to a 0-indexed integer.\n    :param s: The letter sequence (e.g., 'a', 'b', 'aa').\n    :type s: str\n    :returns: The 0-indexed integer representation.",
        "detail": "backup.attach_disk",
        "documentation": {}
    },
    {
        "label": "VIRTIO_DISK_PREFIX",
        "kind": 5,
        "importPath": "backup.attach_disk",
        "description": "backup.attach_disk",
        "peekOfCode": "VIRTIO_DISK_PREFIX = \"vd\"\n# --- End Constants ---\n# Helper functions\ndef _letters_to_int(s: str) -> int:\n    \"\"\"\n    Converts a letter sequence (e.g., 'a', 'aa') to a 0-indexed integer.\n    :param s: The letter sequence (e.g., 'a', 'b', 'aa').\n    :type s: str\n    :returns: The 0-indexed integer representation.\n    :rtype: int",
        "detail": "backup.attach_disk",
        "documentation": {}
    },
    {
        "label": "confirm_guest_disk_unmounted",
        "kind": 2,
        "importPath": "backup.dettach_disk",
        "description": "backup.dettach_disk",
        "peekOfCode": "def confirm_guest_disk_unmounted(dom: libvirt.virDomain, target_dev: str, vm_disk_path: str):\n    \"\"\"\n    Attempts to confirm that the disk is unmounted in the guest OS using QEMU Guest Agent.\n    NOTE: Requires QEMU Guest Agent to be installed and running in the VM.\n    This is a *best effort* check. If QGA isn't working or the disk is raw, it might not confirm.\n    Args:\n        dom: The libvirt domain object.\n        target_dev: The libvirt target device name (e.g., 'vdb').\n        vm_disk_path: A path or identifier for the disk within the guest OS (e.g., '/dev/vdb1' or a mount point).\n                      This is highly guest-OS dependent and may need refinement.",
        "detail": "backup.dettach_disk",
        "documentation": {}
    },
    {
        "label": "detach_disk",
        "kind": 2,
        "importPath": "backup.dettach_disk",
        "description": "backup.dettach_disk",
        "peekOfCode": "def detach_disk(conn: libvirt.virConnect, vm_name: str, target_dev: str):\n    \"\"\"\n    Detaches a disk from a running VM, persisting the change to config.\n    Includes validation and polling.\n    \"\"\"\n    dom = conn.lookupByName(vm_name)\n    if dom is None:\n        raise ValueError(f'VM \"{vm_name}\" not found.')\n    # 1. Get the disk XML\n    disk_xml_to_detach = _get_disk_xml_for_target_dev(dom, target_dev)",
        "detail": "backup.dettach_disk",
        "documentation": {}
    },
    {
        "label": "update_snapshot_metadata",
        "kind": 2,
        "importPath": "backup.dettach_disk",
        "description": "backup.dettach_disk",
        "peekOfCode": "def update_snapshot_metadata(\n    conn: libvirt.virConnect,\n    vm_name: str,\n    snapshot_name: str,\n    custom_namespace_prefix: str,\n    custom_namespace_uri: str,\n    custom_tag_local_name: str,\n    new_custom_tag_value: str\n):\n    \"\"\"",
        "detail": "backup.dettach_disk",
        "documentation": {}
    },
    {
        "label": "main_operation",
        "kind": 2,
        "importPath": "backup.dettach_disk",
        "description": "backup.dettach_disk",
        "peekOfCode": "def main_operation(\n    vm_name: str,\n    target_dev: str,\n    snapshot_name: str,\n    custom_namespace_prefix: str,\n    custom_namespace_uri: str,\n    custom_tag_local_name: str,\n    new_custom_tag_value: str,\n    guest_disk_path_for_qga: str = None # Optional: e.g., '/mnt/data' or '/dev/vdb1'\n):",
        "detail": "backup.dettach_disk",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "backup.dettach_disk",
        "description": "backup.dettach_disk",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# --- Helper Functions ---\ndef _get_disk_xml_for_target_dev(dom: libvirt.virDomain, target_dev: str) -> str:\n    \"\"\"\n    Extracts the XML description of a specific disk from a VM's domain XML.\n    \"\"\"\n    current_dom_xml = dom.XMLDesc(0) # Get persistent XML\n    root = ET.fromstring(current_dom_xml)\n    disk_to_detach_xml = None\n    for disk_elem in root.findall(\".//disk\"):",
        "detail": "backup.dettach_disk",
        "documentation": {}
    },
    {
        "label": "VM_NAME",
        "kind": 5,
        "importPath": "backup.dettach_disk",
        "description": "backup.dettach_disk",
        "peekOfCode": "VM_NAME = \"Fedora39\" # <<--- REPLACE with your VM name\nTARGET_DEVICE_NAME = \"vdb\"  # <<--- REPLACE with the target dev of the disk to detach\nSNAPSHOT_NAME = \"f39_data_snap_archived_20250629\" # <<--- REPLACE with the libvirt name of your external snapshot\n# Your custom namespace details\nCUSTOM_NAMESPACE_PREFIX = \"mycustom\"\nCUSTOM_NAMESPACE_URI = \"http://yourcompany.com/libvirt/snapshot/customdata/1.0\"\nCUSTOM_TAG_LOCAL_NAME = \"archive_status\" # The tag name WITHOUT the prefix\nNEW_CUSTOM_TAG_VALUE = \"detached_for_long_term_archive_20250629\"\n# Optional: Path to the disk/mount point in the guest OS for QGA check\n# IMPORTANT: This needs to be accurate for your guest!",
        "detail": "backup.dettach_disk",
        "documentation": {}
    },
    {
        "label": "TARGET_DEVICE_NAME",
        "kind": 5,
        "importPath": "backup.dettach_disk",
        "description": "backup.dettach_disk",
        "peekOfCode": "TARGET_DEVICE_NAME = \"vdb\"  # <<--- REPLACE with the target dev of the disk to detach\nSNAPSHOT_NAME = \"f39_data_snap_archived_20250629\" # <<--- REPLACE with the libvirt name of your external snapshot\n# Your custom namespace details\nCUSTOM_NAMESPACE_PREFIX = \"mycustom\"\nCUSTOM_NAMESPACE_URI = \"http://yourcompany.com/libvirt/snapshot/customdata/1.0\"\nCUSTOM_TAG_LOCAL_NAME = \"archive_status\" # The tag name WITHOUT the prefix\nNEW_CUSTOM_TAG_VALUE = \"detached_for_long_term_archive_20250629\"\n# Optional: Path to the disk/mount point in the guest OS for QGA check\n# IMPORTANT: This needs to be accurate for your guest!\nGUEST_DISK_PATH_FOR_QGA = \"/mnt/mydata\" # <<--- REPLACE if you use QGA and have a specific path",
        "detail": "backup.dettach_disk",
        "documentation": {}
    },
    {
        "label": "SNAPSHOT_NAME",
        "kind": 5,
        "importPath": "backup.dettach_disk",
        "description": "backup.dettach_disk",
        "peekOfCode": "SNAPSHOT_NAME = \"f39_data_snap_archived_20250629\" # <<--- REPLACE with the libvirt name of your external snapshot\n# Your custom namespace details\nCUSTOM_NAMESPACE_PREFIX = \"mycustom\"\nCUSTOM_NAMESPACE_URI = \"http://yourcompany.com/libvirt/snapshot/customdata/1.0\"\nCUSTOM_TAG_LOCAL_NAME = \"archive_status\" # The tag name WITHOUT the prefix\nNEW_CUSTOM_TAG_VALUE = \"detached_for_long_term_archive_20250629\"\n# Optional: Path to the disk/mount point in the guest OS for QGA check\n# IMPORTANT: This needs to be accurate for your guest!\nGUEST_DISK_PATH_FOR_QGA = \"/mnt/mydata\" # <<--- REPLACE if you use QGA and have a specific path\n# --- Execute ---",
        "detail": "backup.dettach_disk",
        "documentation": {}
    },
    {
        "label": "CUSTOM_NAMESPACE_PREFIX",
        "kind": 5,
        "importPath": "backup.dettach_disk",
        "description": "backup.dettach_disk",
        "peekOfCode": "CUSTOM_NAMESPACE_PREFIX = \"mycustom\"\nCUSTOM_NAMESPACE_URI = \"http://yourcompany.com/libvirt/snapshot/customdata/1.0\"\nCUSTOM_TAG_LOCAL_NAME = \"archive_status\" # The tag name WITHOUT the prefix\nNEW_CUSTOM_TAG_VALUE = \"detached_for_long_term_archive_20250629\"\n# Optional: Path to the disk/mount point in the guest OS for QGA check\n# IMPORTANT: This needs to be accurate for your guest!\nGUEST_DISK_PATH_FOR_QGA = \"/mnt/mydata\" # <<--- REPLACE if you use QGA and have a specific path\n# --- Execute ---\nif __name__ == \"__main__\":\n    main_operation(",
        "detail": "backup.dettach_disk",
        "documentation": {}
    },
    {
        "label": "CUSTOM_NAMESPACE_URI",
        "kind": 5,
        "importPath": "backup.dettach_disk",
        "description": "backup.dettach_disk",
        "peekOfCode": "CUSTOM_NAMESPACE_URI = \"http://yourcompany.com/libvirt/snapshot/customdata/1.0\"\nCUSTOM_TAG_LOCAL_NAME = \"archive_status\" # The tag name WITHOUT the prefix\nNEW_CUSTOM_TAG_VALUE = \"detached_for_long_term_archive_20250629\"\n# Optional: Path to the disk/mount point in the guest OS for QGA check\n# IMPORTANT: This needs to be accurate for your guest!\nGUEST_DISK_PATH_FOR_QGA = \"/mnt/mydata\" # <<--- REPLACE if you use QGA and have a specific path\n# --- Execute ---\nif __name__ == \"__main__\":\n    main_operation(\n        VM_NAME,",
        "detail": "backup.dettach_disk",
        "documentation": {}
    },
    {
        "label": "CUSTOM_TAG_LOCAL_NAME",
        "kind": 5,
        "importPath": "backup.dettach_disk",
        "description": "backup.dettach_disk",
        "peekOfCode": "CUSTOM_TAG_LOCAL_NAME = \"archive_status\" # The tag name WITHOUT the prefix\nNEW_CUSTOM_TAG_VALUE = \"detached_for_long_term_archive_20250629\"\n# Optional: Path to the disk/mount point in the guest OS for QGA check\n# IMPORTANT: This needs to be accurate for your guest!\nGUEST_DISK_PATH_FOR_QGA = \"/mnt/mydata\" # <<--- REPLACE if you use QGA and have a specific path\n# --- Execute ---\nif __name__ == \"__main__\":\n    main_operation(\n        VM_NAME,\n        TARGET_DEVICE_NAME,",
        "detail": "backup.dettach_disk",
        "documentation": {}
    },
    {
        "label": "NEW_CUSTOM_TAG_VALUE",
        "kind": 5,
        "importPath": "backup.dettach_disk",
        "description": "backup.dettach_disk",
        "peekOfCode": "NEW_CUSTOM_TAG_VALUE = \"detached_for_long_term_archive_20250629\"\n# Optional: Path to the disk/mount point in the guest OS for QGA check\n# IMPORTANT: This needs to be accurate for your guest!\nGUEST_DISK_PATH_FOR_QGA = \"/mnt/mydata\" # <<--- REPLACE if you use QGA and have a specific path\n# --- Execute ---\nif __name__ == \"__main__\":\n    main_operation(\n        VM_NAME,\n        TARGET_DEVICE_NAME,\n        SNAPSHOT_NAME,",
        "detail": "backup.dettach_disk",
        "documentation": {}
    },
    {
        "label": "GUEST_DISK_PATH_FOR_QGA",
        "kind": 5,
        "importPath": "backup.dettach_disk",
        "description": "backup.dettach_disk",
        "peekOfCode": "GUEST_DISK_PATH_FOR_QGA = \"/mnt/mydata\" # <<--- REPLACE if you use QGA and have a specific path\n# --- Execute ---\nif __name__ == \"__main__\":\n    main_operation(\n        VM_NAME,\n        TARGET_DEVICE_NAME,\n        SNAPSHOT_NAME,\n        CUSTOM_NAMESPACE_PREFIX,\n        CUSTOM_NAMESPACE_URI,\n        CUSTOM_TAG_LOCAL_NAME,",
        "detail": "backup.dettach_disk",
        "documentation": {}
    },
    {
        "label": "AttachDiskRequest",
        "kind": 6,
        "importPath": "src.api.disk_routes",
        "description": "src.api.disk_routes",
        "peekOfCode": "class AttachDiskRequest(BaseModel):\n    vm_name: str\n    qcow2_path: str\n    target_dev: str = None\nclass DetachDiskRequest(BaseModel):\n    vm_name: str\n    target_dev: str\n@router.post(\"/attach\")\nasync def attach_disk_endpoint(request: AttachDiskRequest):\n    try:",
        "detail": "src.api.disk_routes",
        "documentation": {}
    },
    {
        "label": "DetachDiskRequest",
        "kind": 6,
        "importPath": "src.api.disk_routes",
        "description": "src.api.disk_routes",
        "peekOfCode": "class DetachDiskRequest(BaseModel):\n    vm_name: str\n    target_dev: str\n@router.post(\"/attach\")\nasync def attach_disk_endpoint(request: AttachDiskRequest):\n    try:\n        conn, dom = get_libvirt_domain(request.vm_name)\n        if not request.target_dev:\n            request.target_dev = get_next_available_virtio_dev(dom)\n        success = attach_qcow2_disk(dom, request.qcow2_path, request.target_dev)",
        "detail": "src.api.disk_routes",
        "documentation": {}
    },
    {
        "label": "router",
        "kind": 5,
        "importPath": "src.api.disk_routes",
        "description": "src.api.disk_routes",
        "peekOfCode": "router = APIRouter(prefix=\"/disk\", tags=[\"disk\"])\nclass AttachDiskRequest(BaseModel):\n    vm_name: str\n    qcow2_path: str\n    target_dev: str = None\nclass DetachDiskRequest(BaseModel):\n    vm_name: str\n    target_dev: str\n@router.post(\"/attach\")\nasync def attach_disk_endpoint(request: AttachDiskRequest):",
        "detail": "src.api.disk_routes",
        "documentation": {}
    },
    {
        "label": "get_libvirt_domain",
        "kind": 2,
        "importPath": "src.modules.disk_attach",
        "description": "src.modules.disk_attach",
        "peekOfCode": "def get_libvirt_domain(vm_name: str) -> Tuple[libvirt.virConnect, libvirt.virDomain]:\n    conn = libvirt.open('qemu:///system')\n    if conn is None:\n        raise RuntimeError('Failed to open connection to qemu:///system')\n    dom = conn.lookupByName(vm_name)\n    return conn, dom\ndef get_next_available_virtio_dev(dom: libvirt.virDomain) -> str:\n    xml_desc = dom.XMLDesc(libvirt.VIR_DOMAIN_XML_LIVE)\n    root = ET.fromstring(xml_desc)\n    disk_elements = root.findall(\".//lib:disk\", NAMESPACES)",
        "detail": "src.modules.disk_attach",
        "documentation": {}
    },
    {
        "label": "get_next_available_virtio_dev",
        "kind": 2,
        "importPath": "src.modules.disk_attach",
        "description": "src.modules.disk_attach",
        "peekOfCode": "def get_next_available_virtio_dev(dom: libvirt.virDomain) -> str:\n    xml_desc = dom.XMLDesc(libvirt.VIR_DOMAIN_XML_LIVE)\n    root = ET.fromstring(xml_desc)\n    disk_elements = root.findall(\".//lib:disk\", NAMESPACES)\n    used_all_dev_names = set()\n    for disk in disk_elements:\n        target_element = disk.find('lib:target', NAMESPACES)\n        if target_element is not None:\n            dev = target_element.get('dev')\n            if dev:",
        "detail": "src.modules.disk_attach",
        "documentation": {}
    },
    {
        "label": "attach_qcow2_disk",
        "kind": 2,
        "importPath": "src.modules.disk_attach",
        "description": "src.modules.disk_attach",
        "peekOfCode": "def attach_qcow2_disk(dom: libvirt.virDomain, qcow2_path: str, target_dev: str) -> bool:\n    try:\n        # Check if disk already attached\n        xml_desc = dom.XMLDesc(libvirt.VIR_DOMAIN_XML_LIVE)\n        root = ET.fromstring(xml_desc)\n        for disk in root.findall(\".//lib:disk\", NAMESPACES):\n            target = disk.find('lib:target', NAMESPACES)\n            source = disk.find('lib:source', NAMESPACES)\n            if (target is not None and target.get('dev') == target_dev and\n                source is not None and source.get('file') == qcow2_path):",
        "detail": "src.modules.disk_attach",
        "documentation": {}
    },
    {
        "label": "QCOW2_DEFAULT_SIZE",
        "kind": 5,
        "importPath": "src.modules.disk_attach",
        "description": "src.modules.disk_attach",
        "peekOfCode": "QCOW2_DEFAULT_SIZE = \"1G\"\nLIBVIRT_DOMAIN_NAMESPACE = \"http://libvirt.org/schemas/domain/1.0\"\nNAMESPACES = {'lib': LIBVIRT_DOMAIN_NAMESPACE}\nVIRTIO_DISK_PREFIX = \"vd\"\ndef _letters_to_int(s: str) -> int:\n    res = 0\n    for char in s:\n        res = res * 26 + (ord(char) - ord('a') + 1)\n    return res - 1\ndef _int_to_letters(n: int) -> str:",
        "detail": "src.modules.disk_attach",
        "documentation": {}
    },
    {
        "label": "LIBVIRT_DOMAIN_NAMESPACE",
        "kind": 5,
        "importPath": "src.modules.disk_attach",
        "description": "src.modules.disk_attach",
        "peekOfCode": "LIBVIRT_DOMAIN_NAMESPACE = \"http://libvirt.org/schemas/domain/1.0\"\nNAMESPACES = {'lib': LIBVIRT_DOMAIN_NAMESPACE}\nVIRTIO_DISK_PREFIX = \"vd\"\ndef _letters_to_int(s: str) -> int:\n    res = 0\n    for char in s:\n        res = res * 26 + (ord(char) - ord('a') + 1)\n    return res - 1\ndef _int_to_letters(n: int) -> str:\n    res = \"\"",
        "detail": "src.modules.disk_attach",
        "documentation": {}
    },
    {
        "label": "NAMESPACES",
        "kind": 5,
        "importPath": "src.modules.disk_attach",
        "description": "src.modules.disk_attach",
        "peekOfCode": "NAMESPACES = {'lib': LIBVIRT_DOMAIN_NAMESPACE}\nVIRTIO_DISK_PREFIX = \"vd\"\ndef _letters_to_int(s: str) -> int:\n    res = 0\n    for char in s:\n        res = res * 26 + (ord(char) - ord('a') + 1)\n    return res - 1\ndef _int_to_letters(n: int) -> str:\n    res = \"\"\n    while True:",
        "detail": "src.modules.disk_attach",
        "documentation": {}
    },
    {
        "label": "VIRTIO_DISK_PREFIX",
        "kind": 5,
        "importPath": "src.modules.disk_attach",
        "description": "src.modules.disk_attach",
        "peekOfCode": "VIRTIO_DISK_PREFIX = \"vd\"\ndef _letters_to_int(s: str) -> int:\n    res = 0\n    for char in s:\n        res = res * 26 + (ord(char) - ord('a') + 1)\n    return res - 1\ndef _int_to_letters(n: int) -> str:\n    res = \"\"\n    while True:\n        res = chr(ord('a') + (n % 26)) + res",
        "detail": "src.modules.disk_attach",
        "documentation": {}
    },
    {
        "label": "get_disk_xml_for_target_dev",
        "kind": 2,
        "importPath": "src.modules.disk_detach",
        "description": "src.modules.disk_detach",
        "peekOfCode": "def get_disk_xml_for_target_dev(dom: libvirt.virDomain, target_dev: str) -> str:\n    current_dom_xml = dom.XMLDesc(0)\n    root = ET.fromstring(current_dom_xml)\n    for disk_elem in root.findall(\".//disk\"):\n        target_elem = disk_elem.find(\"target\")\n        if target_elem is not None and target_elem.get(\"dev\") == target_dev:\n            source_elem = disk_elem.find(\"source\")\n            if source_elem is None or not source_elem.get(\"file\"):\n                raise ValueError(f\"Disk '{target_dev}' is not a file-backed disk\")\n            return ET.tostring(disk_elem, encoding='unicode')",
        "detail": "src.modules.disk_detach",
        "documentation": {}
    },
    {
        "label": "poll_for_disk_removal",
        "kind": 2,
        "importPath": "src.modules.disk_detach",
        "description": "src.modules.disk_detach",
        "peekOfCode": "def poll_for_disk_removal(dom: libvirt.virDomain, target_dev: str, timeout: int = 60) -> bool:\n    max_retries = int(timeout / 0.5)\n    for i in range(max_retries):\n        current_dom_xml_live = dom.XMLDesc(libvirt.VIR_DOMAIN_XML_LIVE)\n        root_live = ET.fromstring(current_dom_xml_live)\n        disk_found = False\n        for disk_elem_live in root_live.findall(\".//disk\"):\n            target_elem_live = disk_elem_live.find(\"target\")\n            if target_elem_live is not None and target_elem_live.get(\"dev\") == target_dev:\n                disk_found = True",
        "detail": "src.modules.disk_detach",
        "documentation": {}
    },
    {
        "label": "detach_disk",
        "kind": 2,
        "importPath": "src.modules.disk_detach",
        "description": "src.modules.disk_detach",
        "peekOfCode": "def detach_disk(conn: libvirt.virConnect, vm_name: str, target_dev: str) -> bool:\n    try:\n        dom = conn.lookupByName(vm_name)\n        if dom is None:\n            raise ValueError(f'VM \"{vm_name}\" not found')\n        disk_xml_to_detach = get_disk_xml_for_target_dev(dom, target_dev)\n        detach_flags = libvirt.VIR_DOMAIN_AFFECT_LIVE | libvirt.VIR_DOMAIN_AFFECT_CONFIG\n        ret = dom.detachDeviceFlags(disk_xml_to_detach, detach_flags)\n        if ret != 0:\n            raise RuntimeError(f\"Failed to initiate detach operation\")",
        "detail": "src.modules.disk_detach",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "src.main",
        "description": "src.main",
        "peekOfCode": "app = FastAPI(title=\"KVM Disk Manager\", version=\"1.0.0\")\napp.include_router(disk_routes.router, prefix=\"/api/v1\")\n@app.get(\"/health\")\nasync def health_check():\n    return {\"status\": \"healthy\"}\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)",
        "detail": "src.main",
        "documentation": {}
    }
]